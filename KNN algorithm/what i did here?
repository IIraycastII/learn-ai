Step-by-step breakdown
1. Creating the dataset
data = {
    "x": np.array([1, 2, 3, 4, 5, 6, 5, 3, 4, 6]),
    "y": np.array([2, 4, 1, 3, 6, 5, 6, 3, 2, 1]),
    "color": np.array(["red", "green", "red", "green", "red", "green", "green", "red", "red", "red"])
}
df = pd.DataFrame(data)


You built a small dataset of 10 points, where each point has:

x and y ‚Üí coordinates

color ‚Üí label/class ("red" or "green")

So this acts as your training dataset.

2. Taking user input
input_1 = input("Enter the values here: ")
list_1 = list(map(int, input_1.split()))


You asked the user to input a new (x, y) point ‚Äî for example:

Enter the values here: 3 5


Then you split and converted it into integers like [3, 5].

3. Calculating Euclidean distances
list_euclidean_dist = list(
    math.sqrt((list_1[0] - df["x"][i])**2 + (list_1[1] - df["y"][i])**2)
    for i in range(len(df["x"]))
)


You calculated the distance between your input point and every point in the dataset using the Euclidean formula:

distance=(ùë•2‚àíùë•1)2+(ùë¶2‚àíùë¶1)2
distance=(x2‚àíx1)2+(y2‚àíy1)2
	‚Äã


So you now have a list of distances ‚Äî one for each data point.

4. Choosing number of neighbors
input_2 = int(input("Enter the number of min points to take: "))


This is where you input k ‚Äî the number of nearest neighbors you want to consider.

For example, if you enter 3, the algorithm will look at the 3 closest points to your input.

5. Finding the k-nearest points

You find the smallest distances repeatedly:

for i in range(input_2):
    index = list_euclidean_dist.index(min(list_euclidean_dist))
    index_list.append(index)
    list_min.append(list_euclidean_dist[index])
    list_euclidean_dist.remove(list_euclidean_dist[index])


min(list_euclidean_dist) ‚Üí finds the closest point

index_list ‚Üí stores their positions

You remove the found distance each time so the next iteration finds the next nearest one.

6. Counting color occurrences

Then you checked which color appears more among the chosen neighbors:

list_choices = list(df["color"][index_list[i]] for i in range(len(index_list)))

for j in list_choices:
    if j == "green":
        n_green += 1
    elif j == "red":
        n_red += 1


You looped through the colors of the nearest points and counted red vs green.

7. Making the prediction

Finally, you compared the counts:

if n_green > n_red:
    print("green")
elif n_red > n_green:
    print("red")
elif n_green == n_red:
    print("50% chance of both")


Whichever color appears more among the k-nearest points becomes the predicted color for the new input.
If both are equal, you printed ‚Äú50% chance of both‚Äù (a tie).
